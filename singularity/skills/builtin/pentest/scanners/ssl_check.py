"""SSL/TLS scanner â€” certificate validity, expiry, protocol version, cipher strength."""

import asyncio
import datetime
import socket
import ssl
from typing import Dict, List
from urllib.parse import urlparse

from ..constants import (
    SEVERITY_CRITICAL, SEVERITY_HIGH, SEVERITY_MEDIUM, SEVERITY_INFO,
    make_finding,
)

_OWASP = "A02:2021 Cryptographic Failures"


async def scan_ssl(url: str) -> List[Dict]:
    """Check TLS certificate and connection parameters for *url*."""
    parsed = urlparse(url)
    host = parsed.hostname
    port = parsed.port or (443 if parsed.scheme == "https" else 80)

    if parsed.scheme != "https":
        return [make_finding(
            title="Site not served over HTTPS",
            severity=SEVERITY_HIGH, category="ssl",
            description=f"Target uses {parsed.scheme}:// instead of https://.",
            remediation="Serve all content over HTTPS.", owasp=_OWASP,
        )]

    loop = asyncio.get_event_loop()
    return await loop.run_in_executor(None, _check_ssl_sync, host, port)


def _check_ssl_sync(host: str, port: int) -> List[Dict]:
    findings: List[Dict] = []
    ctx = ssl.create_default_context()
    try:
        with socket.create_connection((host, port)) as sock:
            with ctx.wrap_socket(sock, server_hostname=host) as ssock:
                findings.extend(_check_cert(ssock.getpeercert(), host))
                findings.extend(_check_protocol(ssock.version()))
                findings.extend(_check_cipher(ssock.cipher()))
    except ssl.SSLCertVerificationError as e:
        findings.append(make_finding(
            title="SSL certificate verification failed", severity=SEVERITY_CRITICAL,
            category="ssl", description=f"Verification error: {e}",
            remediation="Install a valid certificate from a trusted CA.", owasp=_OWASP,
        ))
    except (socket.timeout, ConnectionRefusedError, OSError) as e:
        findings.append(make_finding(
            title="Cannot establish TLS connection", severity=SEVERITY_HIGH,
            category="ssl", description=f"Connection failed: {e}",
            remediation="Ensure the server accepts TLS connections.", owasp=_OWASP,
        ))
    findings.extend(_check_deprecated_protocols(host, port))
    return findings


def _check_cert(cert: Dict, host: str) -> List[Dict]:
    findings = []
    if not cert:
        return [make_finding(
            title="No certificate presented", severity=SEVERITY_CRITICAL,
            category="ssl", description="Server did not present a certificate.",
            remediation="Configure a valid TLS certificate.", owasp=_OWASP,
        )]

    not_after = cert.get("notAfter", "")
    if not_after:
        try:
            expiry = datetime.datetime.strptime(not_after, "%b %d %H:%M:%S %Y %Z")
            days_left = (expiry - datetime.datetime.utcnow()).days
            if days_left < 0:
                findings.append(make_finding(
                    title="SSL certificate expired", severity=SEVERITY_CRITICAL,
                    category="ssl",
                    description=f"Expired {abs(days_left)} days ago ({not_after}).",
                    evidence=f"notAfter: {not_after}",
                    remediation="Renew immediately.", owasp=_OWASP,
                ))
            elif days_left < 30:
                findings.append(make_finding(
                    title="SSL certificate expiring soon", severity=SEVERITY_MEDIUM,
                    category="ssl",
                    description=f"Expires in {days_left} days ({not_after}).",
                    evidence=f"notAfter: {not_after}",
                    remediation="Renew before expiry.", owasp=_OWASP,
                ))
        except ValueError:
            pass

    subject = dict(x[0] for x in cert.get("subject", ()))
    cn = subject.get("commonName", "")
    sans = [e[1] for e in cert.get("subjectAltName", ()) if e[0] == "DNS"]
    if host not in sans and cn != host:
        findings.append(make_finding(
            title="Certificate hostname mismatch", severity=SEVERITY_HIGH,
            category="ssl",
            description=f"CN={cn}, SANs={sans} do not match '{host}'.",
            remediation="Use a certificate covering the target hostname.", owasp=_OWASP,
        ))
    return findings


def _check_protocol(protocol: str) -> List[Dict]:
    if protocol in ("SSLv2", "SSLv3", "TLSv1", "TLSv1.1"):
        return [make_finding(
            title=f"Deprecated TLS version: {protocol}", severity=SEVERITY_HIGH,
            category="ssl", description=f"Server negotiated {protocol}.",
            remediation="Disable deprecated protocols. Require TLSv1.2+.", owasp=_OWASP,
        )]
    if protocol == "TLSv1.2":
        return [make_finding(
            title="TLS 1.2 in use (acceptable)", severity=SEVERITY_INFO,
            category="ssl", description="Consider enabling TLSv1.3.",
            remediation="Enable TLSv1.3 support.", owasp=_OWASP,
        )]
    return []


def _check_cipher(cipher_info) -> List[Dict]:
    if not cipher_info:
        return []
    name, _, bits = cipher_info[0], cipher_info[1], cipher_info[2] if len(cipher_info) > 2 else 0
    findings = []
    for weak in ("RC4", "DES", "3DES", "NULL", "EXPORT", "anon"):
        if weak.lower() in name.lower():
            findings.append(make_finding(
                title=f"Weak cipher: {name}", severity=SEVERITY_HIGH, category="ssl",
                description=f"Cipher {name} ({bits} bits) is weak.",
                evidence=f"cipher: {name}, bits: {bits}",
                remediation="Prefer AEAD suites (AES-GCM, ChaCha20).", owasp=_OWASP,
            ))
            break
    if bits and bits < 128:
        findings.append(make_finding(
            title=f"Cipher key too short ({bits} bits)", severity=SEVERITY_HIGH,
            category="ssl", description=f"Cipher {name} uses {bits}-bit keys.",
            remediation="Use >= 128-bit key length.", owasp=_OWASP,
        ))
    return findings


def _check_deprecated_protocols(host: str, port: int) -> List[Dict]:
    findings = []
    protos = []
    if hasattr(ssl, "PROTOCOL_TLSv1"):
        protos.append((ssl.PROTOCOL_TLSv1, "TLSv1.0"))
    if hasattr(ssl, "PROTOCOL_TLSv1_1"):
        protos.append((ssl.PROTOCOL_TLSv1_1, "TLSv1.1"))
    for proto_const, proto_name in protos:
        try:
            ctx = ssl.SSLContext(proto_const)
            ctx.check_hostname = False
            ctx.verify_mode = ssl.CERT_NONE
            with socket.create_connection((host, port)) as sock:
                with ctx.wrap_socket(sock, server_hostname=host):
                    findings.append(make_finding(
                        title=f"Deprecated {proto_name} supported",
                        severity=SEVERITY_MEDIUM, category="ssl",
                        description=f"Server accepts {proto_name} connections.",
                        remediation=f"Disable {proto_name}.", owasp=_OWASP,
                    ))
        except (ssl.SSLError, socket.timeout, ConnectionRefusedError, OSError):
            pass
    return findings
