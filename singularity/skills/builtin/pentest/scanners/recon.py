"""Sensitive paths scanner + report generator â€” combined recon module."""

import asyncio
from typing import Any, Dict, List
from urllib.parse import urljoin

import httpx

from ..constants import (
    SENSITIVE_PATHS,
    SEVERITY_CRITICAL, SEVERITY_HIGH, SEVERITY_MEDIUM, SEVERITY_LOW, SEVERITY_INFO,
    SEVERITY_CVSS, make_finding,
)

_SEM_LIMIT = 10

# ===================================================================
# PATH SCANNER
# ===================================================================


async def scan_paths(client: httpx.AsyncClient, url: str) -> List[Dict]:
    """Enumerate sensitive paths on *url* concurrently."""
    sem = asyncio.Semaphore(_SEM_LIMIT)
    tasks = [_check_path(client, url, path, sem) for path in SENSITIVE_PATHS]
    results = await asyncio.gather(*tasks)
    return [f for f in results if f is not None]


async def _check_path(client, base_url, path, sem) -> Dict | None:
    async with sem:
        try:
            resp = await client.get(urljoin(base_url, path), follow_redirects=False)
        except httpx.HTTPError:
            return None
        if resp.status_code in (404, 410, 403):
            return None
        if resp.status_code in (301, 302):
            return make_finding(
                title=f"Path '{path}' redirects ({resp.status_code})",
                severity=SEVERITY_INFO, category="paths",
                description=f"Redirects to {resp.headers.get('location', '?')}",
                evidence=f"Status: {resp.status_code}",
            )
        if 200 <= resp.status_code < 300:
            return _analyse(path, resp)
        return None


def _analyse(path: str, resp: httpx.Response) -> Dict | None:
    body = resp.text[:5000].lower()
    ct = resp.headers.get("content-type", "").lower()

    if ".env" in path:
        has_secrets = any(k in body for k in ("password", "secret", "api_key", "database_url", "token"))
        return make_finding(
            title=f"Exposed env file: {path}",
            severity=SEVERITY_CRITICAL if has_secrets else SEVERITY_HIGH,
            category="paths",
            description=f"Environment file accessible{' with secrets' if has_secrets else ''}.",
            evidence=f"Status: {resp.status_code}, size: {len(resp.text)}b",
            remediation="Block access to .env files.",
            owasp="A01:2021 Broken Access Control",
        )
    if ".git" in path and ("[core]" in body or "repositoryformatversion" in body):
        return make_finding(
            title=f"Exposed Git repository: {path}",
            severity=SEVERITY_CRITICAL, category="paths",
            description="Git metadata is publicly accessible.",
            remediation="Block access to .git/ directory.",
            owasp="A01:2021 Broken Access Control",
        )
    if ".map" in path and ("sources" in body or "mappings" in body):
        return make_finding(
            title=f"Exposed source map: {path}",
            severity=SEVERITY_MEDIUM, category="paths",
            description="Source map reveals original source code.",
            evidence=f"size: {len(resp.text)}b",
            remediation="Remove source maps from production.",
            owasp="A05:2021 Security Misconfiguration",
        )
    if "admin" in path:
        return make_finding(
            title=f"Accessible admin path: {path}",
            severity=SEVERITY_MEDIUM, category="paths",
            description=f"Admin path returned {resp.status_code}.",
            evidence=f"Content-Type: {ct}",
            remediation="Restrict admin paths.",
            owasp="A01:2021 Broken Access Control",
        )
    if any(k in path for k in ("backup.sql", "dump.sql")):
        return make_finding(
            title=f"Exposed database dump: {path}",
            severity=SEVERITY_CRITICAL, category="paths",
            description="Database dump is publicly accessible.",
            remediation="Remove dumps from web directories.",
            owasp="A01:2021 Broken Access Control",
        )
    if any(k in path for k in ("swagger", "api-docs", "openapi")):
        return make_finding(
            title=f"Exposed API docs: {path}",
            severity=SEVERITY_LOW, category="paths",
            description="API documentation is publicly accessible.",
            remediation="Restrict API docs access.",
            owasp="A05:2021 Security Misconfiguration",
        )
    if path == "/package.json" and "dependencies" in body:
        return make_finding(
            title="Exposed package.json", severity=SEVERITY_LOW, category="paths",
            description="Reveals dependency names and versions.",
            remediation="Don't serve package.json publicly.",
            owasp="A05:2021 Security Misconfiguration",
        )
    if "phpinfo" in path and "php version" in body:
        return make_finding(
            title="Exposed phpinfo()", severity=SEVERITY_MEDIUM, category="paths",
            description="phpinfo reveals server configuration.",
            remediation="Remove phpinfo from production.",
            owasp="A05:2021 Security Misconfiguration",
        )
    if path in ("/.DS_Store", "/.htaccess", "/web.config"):
        return make_finding(
            title=f"Accessible: {path}", severity=SEVERITY_LOW, category="paths",
            description=f"File '{path}' is publicly accessible.",
            remediation=f"Block access to '{path}'.",
            owasp="A05:2021 Security Misconfiguration",
        )
    return None


# ===================================================================
# REPORT GENERATOR
# ===================================================================

OWASP_MAP = {
    "A01:2021 Broken Access Control": "A01:2021",
    "A02:2021 Cryptographic Failures": "A02:2021",
    "A03:2021 Injection": "A03:2021",
    "A05:2021 Security Misconfiguration": "A05:2021",
}


def generate_report(url: str, cached_results: Dict[str, List[Dict]]) -> Dict[str, Any]:
    """Aggregate cached scan results into a full report."""
    all_findings: List[Dict] = []
    for findings in cached_results.values():
        all_findings.extend(findings)

    all_findings.sort(key=lambda f: f.get("cvss", 0), reverse=True)

    # Counts by severity
    counts = {s: 0 for s in (SEVERITY_CRITICAL, SEVERITY_HIGH, SEVERITY_MEDIUM, SEVERITY_LOW, SEVERITY_INFO)}
    for f in all_findings:
        sev = f.get("severity", SEVERITY_INFO)
        counts[sev] = counts.get(sev, 0) + 1

    # Risk score 0-100
    risk_score = min(100, int(
        counts[SEVERITY_CRITICAL] * 25
        + counts[SEVERITY_HIGH] * 15
        + counts[SEVERITY_MEDIUM] * 5
        + counts[SEVERITY_LOW] * 1
    ))

    # OWASP mapping
    owasp_hits: Dict[str, int] = {}
    for f in all_findings:
        owasp = f.get("owasp", "")
        if owasp:
            key = OWASP_MAP.get(owasp, owasp)
            owasp_hits[key] = owasp_hits.get(key, 0) + 1

    # Remediation priorities (top 5 critical/high findings)
    priorities = [
        {"title": f["title"], "severity": f["severity"], "remediation": f.get("remediation", "")}
        for f in all_findings
        if f["severity"] in (SEVERITY_CRITICAL, SEVERITY_HIGH)
    ][:5]

    risk_label = "Critical" if risk_score >= 75 else "High" if risk_score >= 50 else "Medium" if risk_score >= 25 else "Low"

    return {
        "url": url,
        "risk_score": risk_score,
        "risk_label": risk_label,
        "total_findings": len(all_findings),
        "severity_counts": counts,
        "owasp_coverage": owasp_hits,
        "remediation_priorities": priorities,
        "findings": all_findings,
    }
