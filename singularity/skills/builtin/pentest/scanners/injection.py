"""SQL injection + XSS scanner â€” combined injection testing module."""

import time
from typing import Dict, List
from urllib.parse import urljoin

import httpx

from ..constants import (
    SQLI_ERROR_PAYLOADS, SQLI_ERROR_SIGNATURES,
    SQLI_TIME_PAYLOADS, SQLI_BOOLEAN_PAYLOADS,
    XSS_CANARIES,
    SEVERITY_CRITICAL, SEVERITY_HIGH, SEVERITY_MEDIUM, SEVERITY_INFO,
    discover_inputs, make_finding,
)


# ===================================================================
# SQL INJECTION
# ===================================================================

async def scan_sqli(client: httpx.AsyncClient, url: str) -> List[Dict]:
    """Run SQL injection checks against forms on *url*."""
    resp = await client.get(url, follow_redirects=True)
    forms = discover_inputs(resp.text, str(resp.url))
    if not forms:
        return [make_finding(
            title="No injectable inputs found", severity=SEVERITY_INFO,
            category="sqli", description="No forms or input fields were discovered.",
        )]

    findings: List[Dict] = []
    for form in forms:
        target = urljoin(str(resp.url), form["action"]) if form["action"] else str(resp.url)
        findings.extend(await _test_error_sqli(client, target, form["method"], form["fields"]))
        findings.extend(await _test_time_sqli(client, target, form["method"], form["fields"]))
        findings.extend(await _test_bool_sqli(client, target, form["method"], form["fields"]))
    return findings


async def _submit(client, url, method, fields, target_field, payload):
    data = {f["name"]: (payload if f["name"] == target_field else "test") for f in fields}
    if method == "GET":
        return await client.get(url, params=data, follow_redirects=True)
    return await client.post(url, data=data, follow_redirects=True)


async def _test_error_sqli(client, url, method, fields) -> List[Dict]:
    for field in fields:
        for payload in SQLI_ERROR_PAYLOADS:
            try:
                resp = await _submit(client, url, method, fields, field["name"], payload)
                body = resp.text.lower()
                for sig in SQLI_ERROR_SIGNATURES:
                    if sig in body:
                        return [make_finding(
                            title=f"SQL injection (error-based) in '{field['name']}'",
                            severity=SEVERITY_CRITICAL, category="sqli",
                            description=f"Payload '{payload}' triggered SQL error.",
                            evidence=f"Signature: '{sig}'",
                            remediation="Use parameterised queries.",
                            owasp="A03:2021 Injection",
                        )]
            except httpx.HTTPError:
                continue
    return []


async def _test_time_sqli(client, url, method, fields) -> List[Dict]:
    for field in fields:
        try:
            t0 = time.monotonic()
            await _submit(client, url, method, fields, field["name"], "test")
            baseline = time.monotonic() - t0
        except httpx.HTTPError:
            continue
        for payload in SQLI_TIME_PAYLOADS:
            try:
                t0 = time.monotonic()
                await _submit(client, url, method, fields, field["name"], payload)
                elapsed = time.monotonic() - t0
                if elapsed > baseline + 2.5:
                    return [make_finding(
                        title=f"SQL injection (time-based) in '{field['name']}'",
                        severity=SEVERITY_CRITICAL, category="sqli",
                        description=f"Payload '{payload}' caused {elapsed:.1f}s delay (baseline {baseline:.1f}s).",
                        evidence=f"Delay: {elapsed:.1f}s vs {baseline:.1f}s",
                        remediation="Use parameterised queries.",
                        owasp="A03:2021 Injection",
                    )]
            except httpx.HTTPError:
                continue
    return []


async def _test_bool_sqli(client, url, method, fields) -> List[Dict]:
    for field in fields:
        for true_p, false_p in SQLI_BOOLEAN_PAYLOADS:
            try:
                true_r = await _submit(client, url, method, fields, field["name"], true_p)
                false_r = await _submit(client, url, method, fields, field["name"], false_p)
                diff = abs(len(true_r.text) - len(false_r.text))
                if diff > 100:
                    return [make_finding(
                        title=f"SQL injection (boolean-based) in '{field['name']}'",
                        severity=SEVERITY_HIGH, category="sqli",
                        description=f"True/false payloads differ by {diff} bytes.",
                        evidence=f"True: {len(true_r.text)}b, False: {len(false_r.text)}b",
                        remediation="Use parameterised queries.",
                        owasp="A03:2021 Injection",
                    )]
            except httpx.HTTPError:
                continue
    return []


# ===================================================================
# XSS
# ===================================================================

async def scan_xss(client: httpx.AsyncClient, url: str) -> List[Dict]:
    """Run XSS checks against forms and URL parameters on *url*."""
    resp = await client.get(url, follow_redirects=True)
    forms = discover_inputs(resp.text, str(resp.url))
    has_csp = "content-security-policy" in {k.lower() for k in resp.headers}

    if not forms:
        results = await _test_url_reflection(client, url, has_csp)
        return results or [make_finding(
            title="No XSS injection points found", severity=SEVERITY_INFO,
            category="xss", description="No forms or reflective URL params discovered.",
        )]

    findings: List[Dict] = []
    for form in forms:
        target = urljoin(str(resp.url), form["action"]) if form["action"] else str(resp.url)
        findings.extend(await _test_form_xss(client, target, form["method"], form["fields"], has_csp))
    return findings


async def _test_form_xss(client, url, method, fields, has_csp) -> List[Dict]:
    for field in fields:
        for canary in XSS_CANARIES:
            data = {f["name"]: (canary["payload"] if f["name"] == field["name"] else "test") for f in fields}
            try:
                if method == "GET":
                    resp = await client.get(url, params=data, follow_redirects=True)
                else:
                    resp = await client.post(url, data=data, follow_redirects=True)
                if canary["canary"] in resp.text:
                    ctx = _detect_context(resp.text, canary["canary"])
                    sev = SEVERITY_MEDIUM if has_csp else SEVERITY_HIGH
                    desc = f"Payload reflected unencoded in {ctx} context."
                    if has_csp:
                        desc += " CSP may mitigate exploitation."
                    return [make_finding(
                        title=f"Reflected XSS in '{field['name']}' ({ctx} context)",
                        severity=sev, category="xss", description=desc,
                        evidence=_snippet(resp.text, canary["canary"]),
                        remediation="Encode user input with context-appropriate escaping.",
                        owasp="A03:2021 Injection",
                    )]
            except httpx.HTTPError:
                continue
    return []


async def _test_url_reflection(client, url, has_csp) -> List[Dict]:
    canary = "w1s3nt_xss_probe"
    sep = "&" if "?" in url else "?"
    try:
        resp = await client.get(f"{url}{sep}q={canary}", follow_redirects=True)
        if canary not in resp.text:
            return []
        html_tag = f"<b>{canary}</b>"
        resp2 = await client.get(f"{url}{sep}q={html_tag}", follow_redirects=True)
        if html_tag in resp2.text:
            sev = SEVERITY_MEDIUM if has_csp else SEVERITY_HIGH
            return [make_finding(
                title="Reflected XSS via URL query parameter",
                severity=sev, category="xss",
                description="HTML injected via 'q' param reflected unencoded.",
                evidence=_snippet(resp2.text, html_tag),
                remediation="Encode user input before rendering.",
                owasp="A03:2021 Injection",
            )]
    except httpx.HTTPError:
        pass
    return []


def _detect_context(body: str, marker: str) -> str:
    idx = body.find(marker)
    if idx < 0:
        return "unknown"
    prefix = body[max(0, idx - 200):idx].lower()
    if "<script" in prefix and "</script>" not in prefix:
        return "script"
    if "value=" in prefix[-50:] or "'" in prefix[-5:] or '"' in prefix[-5:]:
        return "attribute"
    return "html"


def _snippet(body: str, marker: str, ctx: int = 80) -> str:
    idx = body.find(marker)
    if idx < 0:
        return ""
    start, end = max(0, idx - ctx), min(len(body), idx + len(marker) + ctx)
    return f"...{body[start:end]}..."
