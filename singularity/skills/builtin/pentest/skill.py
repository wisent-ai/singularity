"""PentestSkill — non-destructive security vulnerability scanning for websites."""

from typing import Dict, List

import httpx

from singularity.skills.base import Skill, SkillResult, SkillManifest, SkillAction
from .scanners import scan_headers, scan_ssl, scan_sqli, scan_xss, scan_paths, generate_report


def _a(name, desc, params=None, prob=0.9, dur=15):
    return SkillAction(name=name, description=desc, parameters=params or {},
                       estimated_cost=0, estimated_duration_seconds=dur,
                       success_probability=prob)


_URL_PARAM = {"url": {"type": "string", "required": True, "description": "Target URL to scan (must be a site you own or have permission to test)"}}
_TIMEOUT = 20
_UA = "WisentPentestBot/1.0 (security-scan; non-destructive)"


class PentestSkill(Skill):
    """Non-destructive security scanner for websites."""

    def __init__(self, credentials: Dict[str, str] = None):
        super().__init__(credentials)
        self._cache: Dict[str, Dict[str, List[Dict]]] = {}  # url -> {scanner_name -> findings}

    @property
    def manifest(self) -> SkillManifest:
        return SkillManifest(
            skill_id="pentest",
            name="Security Scanner",
            version="1.0.0",
            category="security",
            description="Non-destructive security vulnerability scanner. Checks headers, SSL, SQLi, XSS, and sensitive paths.",
            required_credentials=[],
            install_cost=0,
            author="system",
            actions=[
                _a("scan", "Run all security scanners on a URL and return sorted findings",
                   _URL_PARAM, dur=60),
                _a("headers", "Check security headers, CORS, cookies, and info disclosure",
                   _URL_PARAM),
                _a("ssl", "Check SSL/TLS certificate, protocol version, and cipher strength",
                   _URL_PARAM),
                _a("sqli", "Test forms for SQL injection vulnerabilities",
                   _URL_PARAM, prob=0.85, dur=30),
                _a("xss", "Test forms and URL params for cross-site scripting",
                   _URL_PARAM, prob=0.85, dur=30),
                _a("paths", "Enumerate sensitive paths (env files, git, admin, source maps)",
                   _URL_PARAM, dur=20),
                _a("report", "Generate aggregate report from cached scan results",
                   _URL_PARAM, dur=2),
            ],
        )

    def _client(self) -> httpx.AsyncClient:
        return httpx.AsyncClient(
            
            headers={"User-Agent": _UA},
            follow_redirects=True,
        )

    def _cache_results(self, url: str, scanner: str, findings: List[Dict]):
        self._cache.setdefault(url, {})[scanner] = findings

    async def execute(self, action: str, params: Dict) -> SkillResult:
        url = params.get("url", "").strip()
        if not url:
            return SkillResult(success=False, message="'url' parameter is required.")
        if not url.startswith(("http://", "https://")):
            url = f"https://{url}"

        try:
            handler = {
                "scan": self._scan_all,
                "headers": self._scan_headers,
                "ssl": self._scan_ssl,
                "sqli": self._scan_sqli,
                "xss": self._scan_xss,
                "paths": self._scan_paths,
                "report": self._report,
            }.get(action)
            if not handler:
                return SkillResult(success=False, message=f"Unknown action: {action}")
            return await handler(url)
        except Exception as e:
            return SkillResult(success=False, message=f"Scan error: {e}")

    async def _scan_all(self, url: str) -> SkillResult:
        async with self._client() as client:
            for name, scanner in [
                ("headers", lambda: scan_headers(client, url)),
                ("ssl", lambda: scan_ssl(url)),
                ("sqli", lambda: scan_sqli(client, url)),
                ("xss", lambda: scan_xss(client, url)),
                ("paths", lambda: scan_paths(client, url)),
            ]:
                findings = await scanner()
                self._cache_results(url, name, findings)

        report = generate_report(url, self._cache.get(url, {}))
        n = report["total_findings"]
        summary = f"Scan complete — {n} finding(s), risk score {report['risk_score']}/100 ({report['risk_label']})"
        return SkillResult(success=True, message=summary, data=report)

    async def _scan_headers(self, url: str) -> SkillResult:
        async with self._client() as client:
            findings = await scan_headers(client, url)
        self._cache_results(url, "headers", findings)
        return self._findings_result("Headers", findings)

    async def _scan_ssl(self, url: str) -> SkillResult:
        findings = await scan_ssl(url)
        self._cache_results(url, "ssl", findings)
        return self._findings_result("SSL/TLS", findings)

    async def _scan_sqli(self, url: str) -> SkillResult:
        async with self._client() as client:
            findings = await scan_sqli(client, url)
        self._cache_results(url, "sqli", findings)
        return self._findings_result("SQLi", findings)

    async def _scan_xss(self, url: str) -> SkillResult:
        async with self._client() as client:
            findings = await scan_xss(client, url)
        self._cache_results(url, "xss", findings)
        return self._findings_result("XSS", findings)

    async def _scan_paths(self, url: str) -> SkillResult:
        async with self._client() as client:
            findings = await scan_paths(client, url)
        self._cache_results(url, "paths", findings)
        return self._findings_result("Paths", findings)

    async def _report(self, url: str) -> SkillResult:
        cached = self._cache.get(url, {})
        if not cached:
            return SkillResult(success=False, message=f"No cached results for {url}. Run 'scan' first.")
        report = generate_report(url, cached)
        return SkillResult(success=True, message=f"Report: {report['risk_score']}/100", data=report)

    @staticmethod
    def _findings_result(label: str, findings: List[Dict]) -> SkillResult:
        n = len(findings)
        lines = [f"[{f['severity'].upper()}] {f['title']}" for f in findings[:10]]
        summary = f"{label} scan: {n} finding(s)\n" + "\n".join(lines)
        return SkillResult(success=True, message=summary, data={"findings": findings})
